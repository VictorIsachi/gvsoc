diff --git a/occamy.py b/occamy.py
index f0fd40e..925b20d 100644
--- a/occamy.py
+++ b/occamy.py
@@ -33,7 +33,9 @@ from pulp.chips.occamy.soc_reg import SocReg
 from pulp.chips.occamy.quadrant import Quadrant
 import pulp.chips.occamy.occamy_arch
 from pulp.snitch.zero_mem import ZeroMem
+from pulp.cluster.l1_interleaver import L1_interleaver
 import memory.dramsys
+import math
 
 GAPY_TARGET = True
 
@@ -65,6 +67,20 @@ class Soc(gvsoc.systree.Component):
         # Wide 512 bits router
         wide_axi = router.Router(self, 'wide_axi', bandwidth=64)
 
+        # HBM or SOC Demux at Qaudrants Ports
+        hbm_soc_demuxs = []
+        for id in range(0, arch.nb_quadrant):
+            hbm_soc_demuxs.append(router.Router(self, f'hbm_soc_demux_{id}', bandwidth=64))
+
+        #HBM Channel routers
+        hbm_mst_ports = []
+        for id in range(0, arch.nb_quadrant):
+            hbm_mst_ports.append(router.Router(self, f'hbm_mst_ports_{id}', bandwidth=64))
+
+        #HBM Interlever (4096 Bytes Granularity)
+        hbm_interleaver = L1_interleaver(self, 'hbm_interleaver', nb_slaves=arch.nb_hbm_channels,
+            nb_masters=arch.nb_quadrant, interleaving_bits=int(math.log2(4096)))
+
         # Qaudrants
         quadrants = []
         for id in range(0, arch.nb_quadrant):
@@ -126,11 +142,24 @@ class Soc(gvsoc.systree.Component):
 
         # Wide 512 bits router
         for id in range(0, arch.nb_quadrant):
-            quadrants[id].o_WIDE_SOC(wide_axi.i_INPUT())
+            quadrants[id].o_WIDE_SOC(hbm_soc_demuxs[id].i_INPUT())
+            hbm_soc_demuxs[id].o_MAP(wide_axi.i_INPUT())
+            hbm_soc_demuxs[id].o_MAP(hbm_mst_ports[id].i_INPUT(),base=arch.hbm_1_alias.base, size=arch.hbm_1_alias.size, rm_base=True)
             wide_axi.o_MAP ( quadrants[id].i_WIDE_INPUT(), base=arch.quadrant_base(id), size=arch.quadrant.size, rm_base=False )
 
-        # HBM
-        wide_axi.o_MAP ( self.i_HBM(), base=arch.hbm_0_alias.base, size=arch.hbm_0_alias.size, rm_base=True, latency=100 )
+        # HBM interconnect master
+        for id in range(0, arch.nb_quadrant):
+            hbm_mst_ports[id].add_mapping("hbm_int_mst");
+            self.bind(hbm_mst_ports[id],"hbm_int_mst", hbm_interleaver,f'in_{id}')
+
+        # HBM interconnect slave
+        for i in range(0, arch.nb_hbm_channels):
+            self.bind(hbm_interleaver, 'out_%d' % i, self, f'hbm_chan_{i}')
+
+        # hbm_mst_ports[0].o_MAP(self.i_HBM_CHAN(0))
+
+        # Main Simple Memory
+        wide_axi.o_MAP ( self.i_MEM(), base=arch.hbm_0_alias.base, size=arch.hbm_0_alias.size, rm_base=True, latency=100 )
         narrow_axi.o_MAP ( wide_axi.i_INPUT(), base=arch.hbm_0_alias.base, size=arch.hbm_0_alias.size, rm_base=False )
 
         # ROM
@@ -173,11 +202,14 @@ class Soc(gvsoc.systree.Component):
         loader.o_START(host.i_FETCHEN())
         loader.o_ENTRY(host.i_ENTRY())
 
-    def i_HBM(self) -> gvsoc.systree.SlaveItf:
-        return gvsoc.systree.SlaveItf(self, 'hbm', signature='io')
+    def i_MEM(self) -> gvsoc.systree.SlaveItf:
+        return gvsoc.systree.SlaveItf(self, 'mem', signature='io')
 
-    def o_HBM(self, itf: gvsoc.systree.SlaveItf):
-        self.itf_bind('hbm', itf, signature='io')
+    def o_MEM(self, itf: gvsoc.systree.SlaveItf):
+        self.itf_bind('mem', itf, signature='io')
+
+    def i_HBM_CHAN(self, port: int) -> gvsoc.systree.SlaveItf:
+        return gvsoc.systree.SlaveItf(self, f'hbm_chan_{port}', signature='io')
 
 
 
@@ -188,10 +220,14 @@ class Occamy(gvsoc.systree.Component):
 
         soc = Soc(self, 'soc', arch.soc, binary, debug_binaries)
 
-        soc.o_HBM(self.i_HBM())
+        soc.o_MEM(self.i_MEM())
+
+        #Binding on HBM Channels
+        for i in range(0, arch.nb_hbm_channels):
+            self.bind(soc, f'hbm_chan_{i}', self, f'hbm_chan_{i}')
 
-    def i_HBM(self) -> gvsoc.systree.SlaveItf:
-        return gvsoc.systree.SlaveItf(self, 'hbm', signature='io')
+    def i_MEM(self) -> gvsoc.systree.SlaveItf:
+        return gvsoc.systree.SlaveItf(self, 'mem', signature='io')
 
 
 
@@ -205,7 +241,7 @@ class OccamyBoard(gvsoc.systree.Component):
         if args.binary is not None:
             debug_binaries.append(args.binary)
 
-        clock = Clock_domain(self, 'clock', frequency=10000000)
+        clock = Clock_domain(self, 'clock', frequency=1000000000)
 
         arch = pulp.chips.occamy.occamy_arch.OccamyArch(self)
 
@@ -218,7 +254,18 @@ class OccamyBoard(gvsoc.systree.Component):
 
         self.bind(clock, 'out', chip, 'clock')
         self.bind(clock, 'out', mem, 'clock')
-        self.bind(chip, 'hbm', mem, 'input')
+        self.bind(chip, 'mem', mem, 'input')
+
+        #Main HBM Channels
+        hbm_channels = []
+        for i in range(0, arch.nb_hbm_channels):
+            hbm_channels.append(memory.dramsys.Dramsys(self, f'hbm_chan_{i}'))
+            pass
+
+        #Binding on HBM Channels
+        for i in range(0, arch.nb_hbm_channels):
+            self.bind(clock, 'out', hbm_channels[i], 'clock')
+            self.bind(chip, f'hbm_chan_{i}', hbm_channels[i], 'input')
 
 
 
diff --git a/pulp/CMakeLists.txt b/pulp/CMakeLists.txt
index e9710c1..799fbf9 100644
--- a/pulp/CMakeLists.txt
+++ b/pulp/CMakeLists.txt
@@ -16,4 +16,5 @@ add_subdirectory(soc_eu)
 add_subdirectory(stdout)
 add_subdirectory(neureka)
 add_subdirectory(wmem)
-add_subdirectory(spatz)
\ No newline at end of file
+add_subdirectory(spatz)
+add_subdirectory(redmule)
\ No newline at end of file
diff --git a/pulp/chips/occamy/occamy_arch.py b/pulp/chips/occamy/occamy_arch.py
index 186eb9d..00a6876 100644
--- a/pulp/chips/occamy/occamy_arch.py
+++ b/pulp/chips/occamy/occamy_arch.py
@@ -23,6 +23,7 @@ class OccamyArchProperties:
         self.nb_quadrant             = 6
         self.nb_cluster_per_quadrant = 4
         self.nb_core_per_cluster     = 9
+        self.nb_hbm_channels         = 8
         self.hbm_size                = 0x80000000
         self.hbm_type                = 'simple'
 
@@ -64,6 +65,7 @@ class OccamyArch:
 
         self.chip = OccamyArch.Chip(properties)
         self.hbm = OccamyArch.Hbm(properties)
+        self.nb_hbm_channels = properties.nb_hbm_channels
 
     class Hbm:
 
@@ -76,11 +78,13 @@ class OccamyArch:
         def __init__(self, properties):
 
             self.soc = OccamyArch.Chip.Soc(properties)
+            self.nb_hbm_channels = properties.nb_hbm_channels
 
         class Soc:
 
             def __init__(self, properties):
                 self.nb_quadrant = properties.nb_quadrant
+                self.nb_hbm_channels = properties.nb_hbm_channels
                 current_hartid = 0
 
                 self.debug          = Area(    0x0000_0000,     0x0000_0fff)
diff --git a/pulp/idma/be/idma_be_axi.cpp b/pulp/idma/be/idma_be_axi.cpp
index fd38e17..5a15ce4 100644
--- a/pulp/idma/be/idma_be_axi.cpp
+++ b/pulp/idma/be/idma_be_axi.cpp
@@ -36,7 +36,8 @@ IDmaBeAxi::IDmaBeAxi(vp::Component *idma, std::string itf_name, IdmaBeProducer *
     this->be = be;
 
     // Declare master port to AXI interface
-    idma->new_master_port(itf_name, &this->ico_itf);
+    this->ico_itf.set_resp_meth(&IDmaBeAxi::axi_response);
+    idma->new_master_port(itf_name, &this->ico_itf, this);
 
     // Declare our own trace so that we can individually activate traces
     this->traces.new_trace("trace", &this->trace, vp::DEBUG);
@@ -238,16 +239,17 @@ void IDmaBeAxi::axi_response(vp::Block *__this, vp::IoReq *req)
     // on latency
     if (req->get_is_write())
     {
+        _this->trace.msg("[iDMA] axi_response write\n");
         _this->write_handle_req_end(req);
     }
     else
     {
+        _this->trace.msg("[iDMA] axi_response read\n");
         _this->read_handle_req_end(req);
     }
 }
 
 
-
 void IDmaBeAxi::write_burst(uint64_t base, uint64_t size)
 {
     this->enqueue_burst(base, size, true);
diff --git a/pulp/snitch/snitch_cluster/snitch_cluster.py b/pulp/snitch/snitch_cluster/snitch_cluster.py
index 6bd54f1..b793ac0 100644
--- a/pulp/snitch/snitch_cluster/snitch_cluster.py
+++ b/pulp/snitch/snitch_cluster/snitch_cluster.py
@@ -27,6 +27,7 @@ from pulp.idma.snitch_dma import SnitchDma
 from pulp.cluster.l1_interleaver import L1_interleaver
 import gvsoc.runner
 import math
+from pulp.redmule.redmule import RedMule
 
 
 GAPY_TARGET = True
@@ -52,15 +53,18 @@ class ClusterArch:
         self.tcdm          = ClusterArch.Tcdm(base, self.nb_core)
         self.peripheral    = Area( base + 0x0002_0000, 0x0001_0000)
         self.zero_mem      = Area( base + 0x0003_0000, 0x0001_0000)
+        # self.redmule       = Area( base + 0x0020_1000, 0x0001_0000)
+        self.redmule       = Area( 0x1020_1000,        0x0001_0000)
 
     class Tcdm:
         def __init__(self, base, nb_masters):
             self.area = Area( base + 0x0000_0000, 0x0002_0000)
             self.nb_banks_per_superbank = 8
-            self.bank_width = 8
+            self.bank_width = 4
             self.nb_superbanks = 4
             self.bank_size = self.area.size / self.nb_superbanks / self.nb_banks_per_superbank
             self.nb_masters = nb_masters
+            self.nb_hwpe_master = self.nb_banks_per_superbank * self.nb_superbanks
 
 
 class SnitchClusterTcdm(gvsoc.systree.Component):
@@ -72,21 +76,27 @@ class SnitchClusterTcdm(gvsoc.systree.Component):
         nb_banks = arch.nb_superbanks * arch.nb_banks_per_superbank
         for i in range(0, nb_banks):
             banks.append(memory.Memory(self, f'bank_{i}', size=arch.bank_size, atomics=True,
-                width_log2=int(math.log2(arch.bank_width))))
+                width_log2=0)) #int(math.log2(arch.bank_width))
 
         interleaver = L1_interleaver(self, 'interleaver', nb_slaves=nb_banks,
-            nb_masters=arch.nb_masters, interleaving_bits=int(math.log2(arch.bank_width)))
+            nb_masters=arch.nb_masters+1, interleaving_bits=int(math.log2(arch.bank_width)))
 
         dma_interleaver = DmaInterleaver(self, 'dma_interleaver', arch.nb_masters,
             nb_banks, arch.bank_width)
 
+        dma_bw_limit = router.Router(self, 'dma_bw_limit_router', bandwidth=64)
+        dma_bw_limit.add_mapping("output")
+
         for i in range(0, nb_banks):
             self.bind(interleaver, 'out_%d' % i, banks[i], 'input')
             self.bind(dma_interleaver, 'out_%d' % i, banks[i], 'input')
 
         for i in range(0, arch.nb_masters):
-            self.bind(self, f'in_{i}', interleaver, f'in_{i}')
-            self.bind(self, f'dma_input', dma_interleaver, f'input')
+            self.bind(self,             f'in_{i}',      interleaver,        f'in_{i}')
+            self.bind(self,             f'dma_input',   dma_bw_limit,       f'input')
+            self.bind(dma_bw_limit,     f'output',      dma_interleaver,    f'input')
+
+        self.bind(self, f'hwpe_in', interleaver, f'in_{arch.nb_masters}')
 
     def i_INPUT(self, port: int) -> gvsoc.systree.SlaveItf:
         return gvsoc.systree.SlaveItf(self, f'in_{port}', signature='io')
@@ -94,6 +104,9 @@ class SnitchClusterTcdm(gvsoc.systree.Component):
     def i_DMA_INPUT(self) -> gvsoc.systree.SlaveItf:
         return gvsoc.systree.SlaveItf(self, f'dma_input', signature='io')
 
+    def i_HWPE_INPUT(self) -> gvsoc.systree.SlaveItf:
+        return gvsoc.systree.SlaveItf(self, f'hwpe_in', signature='io')
+
 
 
 class SnitchCluster(gvsoc.systree.Component):
@@ -118,6 +131,9 @@ class SnitchCluster(gvsoc.systree.Component):
         # Zero memory
         zero_mem = ZeroMem(self, 'zero_mem', size=arch.zero_mem.size)
 
+        # RedMule
+        redmule = RedMule(self, 'redmule', arch.tcdm.nb_superbanks * arch.tcdm.nb_banks_per_superbank)
+
         # Cores
         cores = []
         cores_ico = []
@@ -174,11 +190,17 @@ class SnitchCluster(gvsoc.systree.Component):
         # Cluster DMA
         idma.o_AXI(wide_axi.i_INPUT())
         idma.o_TCDM(tcdm.i_DMA_INPUT())
+        wide_axi.o_MAP(tcdm.i_DMA_INPUT(), base=arch.tcdm.area.base, size=arch.tcdm.area.size, rm_base=True)
 
         # Zero mem
         wide_axi.o_MAP(zero_mem.i_INPUT(), base=arch.zero_mem.base, size=arch.zero_mem.size, rm_base=True)
         narrow_axi.o_MAP(wide_axi.i_INPUT(), name='zero_mem', base=arch.zero_mem.base, size=arch.zero_mem.size, rm_base=False)
 
+        #RedMule
+        narrow_axi.add_mapping('redmule', base=arch.redmule.base, remove_offset=arch.redmule.base, size=arch.redmule.size)
+        self.bind(narrow_axi, 'redmule', redmule, 'input')
+        self.bind(redmule, 'out', tcdm, 'hwpe_in')
+
     def i_WIDE_INPUT(self) -> gvsoc.systree.SlaveItf:
         return gvsoc.systree.SlaveItf(self, 'wide_input', signature='io')
 
